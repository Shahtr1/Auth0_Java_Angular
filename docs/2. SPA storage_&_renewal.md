## What the Angular SDK stores (and how)

- Access token (AT): short-lived JWT for your API; cached per audience+scope combo.
- Refresh token (RT): rotating, used behind the scenes to mint fresh ATs (because we set `useRefreshTokens: true` and requested `offline_access`).
- ID token (IDT): profile claims for UI; do not send to the API.
- Default cache: in-memory (per tab, cleared on reload). That’s the most XSS-resistant default.

Key point: The SDK fetches a new AT on demand (when you call `getAccessTokenSilently()` or when the HTTP interceptor sees a protected call) and rotates the RT automatically.

## Storage options (choose deliberately)

- A) In-memory (default) — recommended

  Pros: Best protection against token exfiltration via XSS; wiped on reload.

  Cons: Not shared across tabs; reloads may need a quick silent renewal. (With RT rotation enabled, this is seamless.)

  Use this unless you have a strong requirement to persist state across reloads without a refresh.

- B) localStorage (opt-in)

  Enable by adding `cacheLocation: 'localstorage'` to `provideAuth0({...})`.

  Pros: Survives reloads; shared across same-origin tabs.

  Cons: Exposed to any XSS on your origin. If you choose this:
  - Lock down CSP (no `unsafe-inline`; use nonces/sha; enable Trusted Types if possible).
  - Avoid `bypassSecurityTrust…` in Angular; never inject unsanitized HTML.
  - Keep short AT TTL + rotating RT with idle/absolute caps.

- C) Advanced: Worker-isolated cache (pattern)

  Some teams keep tokens in a Web Worker and talk via `postMessage`. This reduces direct access from the main thread. It’s not built into the SDK, but you can wrap `getAccessTokenSilently()` calls behind a worker if your threat model calls for it.

## Renewal mechanics (what actually triggers a refresh)

HTTP interceptor path: any request matching allowedList (we set /api/\*) will:

- Check the cached AT for that audience+scope.
- If missing/expired, call `getAccessTokenSilently()`.
- That uses the rotating RT to mint a new AT (and a new RT), then attaches `Authorization: Bearer …`.

## Proactive “warm-up” on app start

What is “warm-up”?

A one-time, silent token fetch right after your app boots (only if the user is already authenticated).
It pre-populates the SDK’s cache with a fresh access token for your API so your very first `/api/\*` call doesn’t have to pause to mint one.

Removes first-call lag: Without warm-up, your initial API hit often has to wait while the SDK exchanges the rotating Refresh Token (RT) → Access Token (AT). Users perceive that as a “stutter.”

## De-dupe concurrent refreshes (race-safe pattern)

On startup (or a busy screen), several things may ask for a token at the same time:

- your warm-up initializer,
- route guards,
- data resolvers,
- and the HTTP interceptor when the first `/api/\*` calls fire.

If the access token (AT) is expired, each of those may call `getAccessTokenSilently()` simultaneously.

With Refresh Token Rotation (RT), every successful refresh returns a new RT and immediately invalidates the old one.
Multiple concurrent refreshes can:

- waste work (N network calls),
- trip RT reuse detection if your overlap window is tiny,
- create flaky “login again” moments under load.

Goal: ensure that only one refresh is in flight for a given `audience+scope` at any moment, and everyone else waits for that result.
