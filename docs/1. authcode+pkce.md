`/authorize?...` — the authorization request (kick-off of Auth Code + PKCE)

This is the SPA asking Auth0 (the Authorization Server) to start a login/consent transaction:

```arduino
https://<tenant>.us.auth0.com/authorize?
  client_id=...                 // your Angular SPA application's Client ID
  redirect_uri=http://localhost:4200
  response_type=code            // "Auth Code" flow (you'll get ?code=... after login)
  response_mode=query           // the code will come back on the query string
  scope=openid profile email phone address offline_access read:orders write:orders
  audience=https://orders-api   // ask for an access token for your custom API
  state=...                     // CSRF protection + return-to info for the SPA
  nonce=...                     // protects the ID token against replay
  code_challenge=...            // PKCE: SHA-256(code_verifier), base64url
  code_challenge_method=S256    // PKCE method (secure variant)
  auth0Client=...               // SDK+env info (diagnostic/telemetry)

```

## Why each parameter exists (security + behavior)?

- client_id: identifies which application is asking to log in.
- redirect_uri: where Auth0 will send the browser after login. Must be whitelisted in the app settings.
- response_type=code: requests an authorization code (short-lived). Your SPA later exchanges it for tokens using the code_verifier (PKCE).
- response_mode=query: tells Auth0 to put code and state on the URL query string when returning to your app.
- scope:
  - `openid profile email phone address`: standard OIDC claims for the ID token.
  - `offline_access`: asks for a refresh token (you enabled Refresh Token Rotation).
  - `read:orders write:orders`: API scopes you’re requesting for the access token.
  - audience=https://orders-api: crucial; without this, you’d get an access token not meant for your Spring API.
  - state: random, unguessable value; prevents CSRF and lets the SDK restore app state/route after login.
  - nonce: binds the ID token to this request to prevent replay.
  - code_challenge / code_challenge_method=S256: the PKCE piece. Your SPA generated a random `code_verifier` and sent its hash (`code_challenge`). Later, only the party that knows the original `code_verifier` can redeem the code.
  - auth0Client: base64url-encoded JSON that says “this request came from @auth0/auth0-angular vX.Y.Z on Angular 20.2.3”. Helpful for Auth0 diagnostics; harmless to you.

## `/u/login?state=...` — the Universal Login page

Because you didn’t have an active Auth0 session, the `/authorize` request redirects you to the hosted login page:

```perl
https://<tenant>.us.auth0.com/u/login?state=<opaque-transaction-state>
```

- The /u/login path is Auth0’s Universal Login UI.
- The state here is an opaque transaction handle that carries all the necessary details from your `/authorize` request (client, redirect_uri, scopes, PKCE data, etc.). Auth0 uses it to continue the same transaction securely after you submit your credentials.
  If anyone tampers with it, Auth0 will reject the flow.

After you authenticate:

1.  Auth0 redirects the browser to your redirect_uri (`http://localhost:4200`) with `?code=...&state=....`

2.  The Auth0 Angular SDK intercepts that, verifies `state`, and then calls `/oauth/token` (back-channel XHR) with:
    - `grant_type=authorization_code`
    - `code=...` (the short-lived code you just got)
    - `code_verifier=...` (your original PKCE secret)

3.  Auth0 verifies the PKCE pair and returns:
    - ID token (OIDC claims)
    - Access token (JWT for `aud=https://orders-api`)
    - Refresh token (since you asked for `offline_access` and enabled rotation)

4.  Your functional HTTP interceptor attaches `Authorization: Bearer <access_token>` to `/api/\*` calls.
