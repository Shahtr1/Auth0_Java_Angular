## 1. Validate only what you trust (issuer + audience)

Why: a validly-signed token isnâ€™t enoughâ€”it must be for your tenant and for your API.

How

- Keep `issuer-uri` exact (note trailing `/`).
- Add an audience validator

```yaml
spring.security.oauth2.resourceserver.jwt.issuer-uri: https://YOUR_TENANT_REGION.auth0.com/
auth0.audience: https://orders-api
```

## 2. Make the API truly stateless

Why: with Bearer tokens you donâ€™t need HTTP sessions; stateless makes auth simpler and faster.

```java
http
  .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
  .csrf(csrf -> csrf.disable());
```

### Why CSRF isnâ€™t needed for Bearer token APIs

CSRF (Cross-Site Request Forgery) attacks rely on the browser automatically including implicit authentication credentials (like cookies or HTTP Basic auth headers) when making requests to a trusted server.

- In session-based auth (cookies + server state), the browser automatically attaches the session cookie to every request, even if the request is triggered maliciously from another site.
- Thatâ€™s why CSRF protection is needed there â€” to verify the requestâ€™s origin is legitimate (via CSRF tokens, SameSite cookies, etc.).

But with Bearer tokens (JWTs, OAuth2 access tokens, etc.):

- The token is explicitly included in the `Authorization: Bearer <token>` header by the client.
- The browser does not automatically attach it; the frontend code (e.g., React, Angular, etc.) must set the header deliberately.
- A malicious site canâ€™t force your browser to add the header with a valid token (due to same-origin policy and CORS).

ðŸ‘‰ This makes CSRF irrelevant â€” because the attacker canâ€™t smuggle your token into their forged request.
