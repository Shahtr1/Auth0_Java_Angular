Let a command-line app (CLI) running on a machine without an interactive browser session sign a user in and call our Orders API with that user’s permissions (`read:orders` / `write:orders`).

- Native/CLI application (Auth0 “Native” app) – public client, has a client_id (no client secret). It represents the program the user is running.
- User – the human who approves access on a separate browser.
- Auth0 – the authorization server coordinating login/consent and issuing tokens.
- Orders API – your Spring resource server that validates tokens and enforces `SCOPE_read:orders` / `SCOPE_write:orders`

## Why device authorization exists

You only need the Device Authorization (device code) flow if you want a CLI/TV/kiosk to log a user in without an embedded browser. If you don’t need a CLI or any “no-browser” client, you can skip it.

## When Auth Code + PKCE isn’t enough

- Auth Code + PKCE assumes the app has a browser to do redirects.
- A CLI/terminal, TV, kiosk, or SSH box can’t (or shouldn’t) spin up a real browser window.

## What Device Code solves

- Lets the CLI show a short code + URL.
- The user completes login/MFA/SSO in a normal browser (on any device).
- The CLI polls and receives an access token for your Orders API with the user’s permissions.

## Why not the other grants for a CLI?

- Client Credentials: no user at all → tokens represent the app, not a person. You lose per-user RBAC/auditing. Not OK when you need “who did what”.
- Resource Owner Password (ROPC): would force the CLI to collect the user’s password (bad UX and risky). Also bypasses SSO/MFA/IdP policies. Generally discouraged.
- Embedding a browser in the CLI: heavyweight, brittle, and often blocked—still awkward for MFA and enterprise SSO.

## Big picture

This CLI implements the OAuth 2.0 Device Authorization Grant:

1.  Ask Auth0 for a device code (tied to your app via client_id, and to your API via `audience + scope`).
2.  Show the user a verification URL and user code.
3.  Poll Auth0 for tokens until the user approves.
4.  Use the access token to call your Spring Orders API. If `offline_access` was requested and allowed, you also get a refresh token (we just acknowledge it for now; Phase 3 will store/use it).
