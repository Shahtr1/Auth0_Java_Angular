## What we’re adding

A server-to-server client (no human login) that asks Auth0 for an access token using its own client_id + client_secret (the Client Credentials grant),
then calls your Spring API with that token. This is perfect for cron jobs, background workers, or other microservices.

### Auth0 setup

- Created a Machine-to-Machine application (“Orders-worker”).
- Authorized it against your Orders API (audience `https://orders-api`) and granted scopes:
  - reader worker → `read:orders`
  - writer worker → `read:orders write:orders`
- (No refresh tokens in this flow.) We rely on short AT TTL and re-request tokens when needed.

### Worker implementation (Java)

- Built a tiny Java 21 console app using `HttpClient` + Jackson:

  1.  Token request: `POST https://{AUTH0_DOMAIN}/oauth/token`
      - body: `grant_type=client_credentials`, `client_id`, `client_secret`, `audience`
  2.  API call: attach `Authorization: Bearer <access_token>` to `/api/orders` (GET/POST).

- Kept credentials out of code via environment variables.
- Packaged as a shaded (fat) JAR, so it runs anywhere with `java -jar …` (no external classpath).

### How we tested it

- Read mode (only `read:orders` granted):

  - `GET /api/orders` → 200 OK
  - `POST /api/orders` → 403 Forbidden (as expected)

- Write mode (after granting `write:orders`):

  - `POST /api/orders` → 201 Created

- Also hit `/api/whoami` with the M2M token to confirm:
  - `aud` = `https://orders-api`
  - `sub` is a client (not a user)
  - `scope` includes `read:orders`/`write:orders`
  - Spring `authorities` show `SCOPE_read:orders` / `SCOPE_write:orders`
